计64	嵇天颖	2016010308

## LAB 3

[TOC]

---

### 练习0：填写已有实验

> 本实验依赖实验1/2。请把你做的实验1/2的代码填入本实验中代码中有“LAB1”,“LAB2”的注释相应部分。

利用`diff/merge`工具实现代码的合并。



### 练习1：给未被映射的地址映射上物理页

#### 【练习1.1】

> 完成`do_pgfault（mm/vmm.c）`函数，给未被映射的地址映射上物理页。设置访问权限 的时候需要参考页面所在 `VMA `的权限，同时需要注意映射物理页时需要操作内存控制 结构所指定的页表，而不是内核的页表。

##### 设计原理分析

（1）某一些虚拟内存的空间是合法的，但尚未给它们分配具体的内存页。如果我们访问这些虚拟内存页的时候，就会发生`page fault`异常。

（2）我们利用`page fault`异常，让操作系统在进行异常处理的时候对这些合法的虚拟内存页分配相应的物理内存页。这样我们从中断返回的时候就能进行正常的内存访问。

（3）`page fault`处理流程：`trap_dispatch`函数会根据`page fault`的中断号，将它交给`pgfault_handler`函数，从而进一步交给`do_pgfault`函数进行处理。

##### 设计思路

（1）检查页表中是否有相应的表项，如果表项为空，则说明没有映射过；

* 使用在`lab2`中实现的函数`get_pte`来获取线性地址所对应的虚拟页的起始地址对应到的页表项。
* 如果查询到的`PTE`不为0，则表示对应的物理页可能在内存中或者在外存中，否则就表示对应的物理页尚未被分配，

（2）为没有映射的虚拟页分配一个物理页，并确认分到的物理页不为空。

* `pgdir_alloc_page`函数实现了内存分配功能，我们用这个函数来获取对应的物理页，并且将其与当前的虚拟页设置上映射关系，我们以此来为未被映射的地址映射上物理页。

##### 代码实现

根据注释的提示，我们在`do_pgfault`中补全下面的代码：

首先获取发生缺页错误的`PTE` ，如果`PTE`为0, 说明虚页不存在, 则使用`pgdir_alloc_page`分配。

~~~c
//(1) try to find a pte, if pte's PT(Page Table) isn't existed, then create a PT.
if ((ptep = get_pte(mm->pgdir, addr, 1)) == NULL) {
    cprintf("get_pte in do_pgfault failed\n");
    return ret;
}
//(2) if the phy addr isn't exist, then alloc a page & map the phy addr with logical addr.
if (*ptep == 0) {
    if (pgdir_alloc_page(mm->pgdir, addr, perm) == NULL) {
        cprintf("pgdir_alloc_page in do_pgfault failed\n");
        return ret;
    }
}
~~~



#### 【练习1.2】

> 请描述页目录项（`Page Directory Entry`）和页表项（`Page Table Entry`）中组成部分对`ucore`实现页替换算法的潜在用处。

（1）首先我们观察并了解页目录项和页表项的组成部分和其作用：

页目录项和页表项的组成结构是相同的，区别在于高20位存储的内容不同。

页目录项存储的是二级页表的物理页帧号，而页表项存储的是虚拟地址对应的页帧号。

| 位    | 说明                       |                                  |
| ----- | -------------------------- | -------------------------------- |
| 31-12 | 页表页帧号                 |                                  |
| 11-9  | PTE_AVAIL                  | 保留专供程序使用，处理器不会修改 |
| 8-7   | PTE_MBZ，Bits must be zero |                                  |
| 6     | PTE_D，Dirty               | 页面是否被修改过                 |
| 5     | PTE_A，Accessed            | 页面是否被访问过                 |
| 4     | PTE_PCD，Cache-Disable     | 是否禁用Cache                    |
| 3     | PTE_PWT，Write-Through     | 是否采用写直达                   |
| 2     | PTE_U, User can access     | 超级用户标志位                   |
| 1     | PTE_W, Writeable           | 页面是否可读写                   |
| 0     | PTE_P, Present             | 指明表项对地址转换是否有效       |

（2）下面我们分析页目录项和页表项的组成部分对页替换算法的用处：

* 页目录项（`pgdir`）作为一个双向链表存储了目前所有的页的物理地址和逻辑地址的对应，即在实内存中的所有页，替换算法中被换出的页从`pgdir`中选出。

* 页表（`pte`）则存储了替换算法中被换入的页的信息，替换后会将其映射到一物理地址。
* 表项中`PTE_A`表示内存页是否被访问过，`PTE_D`表示内存页是否被修改过，这两个标志位可以成为局部页替换算法选取换出页的依据。



#### 【练习1.3】

> 如果`ucore`的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

（1）**进入中断处理**

CPU在执行完一个指令后开始读取中断信号，获取到中断index及相应的error code信息等；接下来，CPU会将相应的error code及寄存器状态等存储在trapframe中，并根据异常对应向量值去IDT中寻找中断描述符。

中断描述符中存储着中断例程对应的`selector`和`offse`t，通过这两个值将`CS：EIP`定位到中断服务例程上，也就是我们的`do_pgfault`上进行后续处理。

之后，`CPU`会根据`CPL`和`DPL`确认是否发生了特权级的转换。然后保存现场，开始执行中断服务例程。

（2）**缺页异常处理**

发生缺页异常时，中断服务例程会将缺失的页调入到内存中，有些情况下会进行页置换。根据情况修改页表。

（3）**完成中断处理**

每个中断服务例程在有中断处理工作完成后需要通过`iret`（或`iretd`）指令恢复被打断的程序的执行。恢复现场保存信息，并完成特权级的转换。回到出现异常的语句继续执行。